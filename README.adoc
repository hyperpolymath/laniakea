= Laniakea
:toc: macro
:toc-title: Contents
:toclevels: 4
:icons: font
:source-highlighter: rouge
:experimental:
:sectanchors:
:sectlinks:

[.lead]
*The browser isn't a client â€” it's a peer node in a distributed system where state flows and converges.*

image::https://img.shields.io/badge/status-Phase%200-blue[Status]
image::https://img.shields.io/badge/license-MIT%20%2F%20Apache--2.0-green[License]
image::https://img.shields.io/badge/elixir-%3E%3D%201.15-purple[Elixir]

toc::[]

== What is Laniakea?

Laniakea is a *transcendent architecture* for building distributed web applications where browsers participate as peer nodes in a BEAM cluster, not as dumb terminals receiving server pushes.

Named after the https://en.wikipedia.org/wiki/Laniakea_Supercluster[Laniakea Supercluster] â€” the cosmic structure containing our galaxy â€” this project embodies the idea that individual nodes (browsers) are part of a larger, interconnected system where state flows and converges across vast distances.

=== Core Principles

[cols="1,2"]
|===
|Principle |Description

|*State Convergence*
|Neither server nor client "owns" state. CRDTs ensure eventual consistency without coordination.

|*Browser as Peer*
|The browser runs BEAM-compatible semantics, participating in the distributed system.

|*Capability Negotiation*
|Clients declare capabilities; servers adapt behavior (update frequency, batching, rendering).

|*Offline-First*
|Local CRDT operations continue offline; state merges upon reconnection.

|*Progressive Enhancement*
|Works with WebSocket today, WebTransport where available, full BEAM-in-browser later.
|===

=== The Vision

[source]
----
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 TRANSCENDENT ARCHITECTURE                   â”‚
â”‚                                                             â”‚
â”‚      Server BEAM Nodes              Browser BEAM Nodes      â”‚
â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚      â”‚ OTP Full Stack  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Isomorphic      â”‚    â”‚
â”‚      â”‚ - Supervisors   â”‚  Streams   â”‚ - Local Sups    â”‚    â”‚
â”‚      â”‚ - Distribution  â”‚  & CRDTs   â”‚ - CRDT Mirrors  â”‚    â”‚
â”‚      â”‚ - CRDT Registry â”‚            â”‚ - UI Processes  â”‚    â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚              â”‚                              â”‚               â”‚
â”‚              â”‚         State Flows          â”‚               â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                                                             â”‚
â”‚            Neither "owns" â€” state converges.                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
----

== Why Laniakea?

=== The Problem with Traditional Web Architecture

[cols="1,1"]
|===
|Traditional |Laniakea

|Server owns state
|State converges across nodes

|Client is a dumb terminal
|Client is a BEAM peer

|Offline = broken
|Offline = local CRDT ops

|JS runtime quirks
|BEAM semantics everywhere

|Hope nothing crashes
|Supervision trees in browser

|REST/GraphQL request-response
|Bidirectional streams + CRDTs
|===

=== Why Now?

1. **WebAssembly matured** â€” Threads, GC proposal, Component Model enable real runtimes
2. **CRDTs went production** â€” Figma, Linear, Notion proved they scale
3. **Elixir proved the model** â€” Discord, WhatsApp, Pinterest: millions of concurrent users
4. **JS ecosystem fatigue** â€” Dependency sprawl, security issues, bundle bloat
5. **Popcorn/AtomVM emerged** â€” Lightweight BEAM-in-browser is now tractable

== Architecture

=== Phase 0: Demonstrable Now

What works today with Phoenix + ReScript + CRDTs:

[source]
----
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DEMONSTRABLE NOW                         â”‚
â”‚                                                             â”‚
â”‚  [Phoenix Server]              [ReScript/Elm Client]        â”‚
â”‚       â”‚                              â”‚                      â”‚
â”‚       â”œâ”€â”€ CRDT State (G-Counter)     â”œâ”€â”€ CRDT Mirror        â”‚
â”‚       â”œâ”€â”€ Phoenix Channels           â”œâ”€â”€ Typed Adapters     â”‚
â”‚       â”œâ”€â”€ Capability Negotiation     â”œâ”€â”€ DOM Rendering      â”‚
â”‚       â””â”€â”€ Command Bus                â””â”€â”€ Offline Outbox     â”‚
â”‚                                                             â”‚
â”‚  Transport: WebSocket (today), WebTransport (where avail)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
----

=== Phased Implementation

[cols="1,3,2"]
|===
|Phase |Description |Status

|*Phase 0*
|Core demo: CRDTs + Phoenix Channels + capability negotiation
|âœ… Implementable now

|*Phase 1*
|Delta-based CRDT sync, typed command/event envelopes
|ðŸ”„ In progress

|*Phase 2*
|Transport hedging (WebTransport), OTEL observability
|ðŸ“‹ Planned

|*Phase 3*
|Zig/Wasm runtime bridge OR Popcorn/AtomVM integration
|ðŸ”¬ Research

|*Phase 4*
|Full BEAM-in-browser with supervision trees
|ðŸŒŸ Vision
|===

=== Component Overview

==== Server (Elixir/Phoenix)

[source,elixir]
----
# CRDT Registry - manages distributed state
defmodule Laniakea.CRDT.Registry do
  use GenServer
  # Stores CRDTs by ID, broadcasts deltas to connected clients
end

# Capability Policy - adapts to client capabilities
defmodule Laniakea.Policy do
  def assign_profile(capabilities) do
    cond do
      full_capabilities?(capabilities) -> :full_client
      partial_capabilities?(capabilities) -> :constrained_client
      true -> :minimal_client
    end
  end
end

# Command Bus - typed command processing
defmodule Laniakea.CommandBus do
  def handle(%{type: "crdt.increment", payload: p}, state) do
    # Process command, return events
  end
end
----

==== Client (ReScript/Elm)

[source,rescript]
----
// G-Counter CRDT - isomorphic with server
module GCounter = {
  type t = {counts: Map.String.t<int>, version: int}

  let merge = (a, b) => {
    // Commutative, associative, idempotent
    // merge(a, b) == merge(b, a)
  }
}

// Capability Probe - detect browser features
module Capabilities = {
  let probe = () => {
    hasWorkers: Worker.available(),
    hasSharedArrayBuffer: SharedArrayBuffer.available(),
    // ...
  }
}
----

==== CRDTs

Laniakea uses Conflict-free Replicated Data Types for coordination-free state convergence:

[cols="1,2,2"]
|===
|CRDT |Use Case |Properties

|*G-Counter*
|Increment-only counters (views, likes)
|Grow-only, merge = max per node

|*PN-Counter*
|Increment/decrement counters
|Pair of G-Counters (positive/negative)

|*G-Set*
|Add-only sets (tags, participants)
|Union on merge

|*OR-Set*
|Add/remove sets with observed-remove
|Handles concurrent add/remove

|*LWW-Register*
|Last-writer-wins single values
|Timestamp-based conflict resolution

|*RGA*
|Collaborative text sequences
|Replicated Growable Array
|===

== Comparison: Laniakea vs Alternatives

=== vs Traditional SPA (React/Next.js)

[cols="2,2,2"]
|===
|Aspect |React/Next.js |Laniakea

|*State ownership*
|Server owns, client caches
|State converges via CRDTs

|*Offline support*
|Requires explicit implementation
|Built-in (CRDTs work offline)

|*Type safety*
|Optional (TypeScript)
|Mandatory (ReScript/Elm)

|*Concurrency model*
|Single-threaded event loop
|BEAM processes (browser)

|*Error handling*
|Try/catch, error boundaries
|Supervision trees

|*Real-time sync*
|WebSocket + custom logic
|Phoenix Channels + CRDTs
|===

=== vs Elm

[cols="2,2,2"]
|===
|Aspect |Elm |Laniakea

|*Runtime*
|Elm runtime (JS)
|BEAM semantics (browser)

|*Server integration*
|HTTP/WebSocket (manual)
|Phoenix Channels (native)

|*State sync*
|Manual implementation
|CRDT convergence

|*Distribution*
|Single-page app
|Distributed peer node

|*Type system*
|Hindley-Milner
|Dialyzer + ReScript
|===

=== vs LiveView

[cols="2,2,2"]
|===
|Aspect |Phoenix LiveView |Laniakea

|*Rendering*
|Server-rendered, diff pushed
|Client renders, state converges

|*Offline*
|Requires connection
|Full offline support

|*State location*
|Server owns state
|State exists everywhere

|*Latency sensitivity*
|High (all actions round-trip)
|Low (local operations)

|*Scalability*
|Server resources per client
|Clients do local work
|===

=== vs Lumen/Firefly (Archived)

[cols="2,2,2"]
|===
|Aspect |Lumen/Firefly |Laniakea

|*Approach*
|Reimplement BEAM in Rust
|Extend cluster to browser

|*Scope*
|Full OTP reimplementation
|State convergence only

|*Distribution*
|Not addressed
|Core feature (CRDTs)

|*Incremental value*
|All or nothing
|Phase 0 works today

|*Status*
|âŒ Archived June 2024
|âœ… Active development
|===

=== vs Popcorn/AtomVM

Laniakea and Popcorn are *complementary*:

- **Popcorn** provides BEAM-in-browser runtime via AtomVM compiled to Wasm
- **Laniakea** provides the architecture for distributed state convergence

Future integration: Laniakea client runs on Popcorn runtime, giving us actual OTP in browser.

== Quick Start

=== Prerequisites

* Elixir >= 1.15
* Node.js >= 18
* PostgreSQL (optional, for persistence)

=== Setup

[source,bash]
----
# Clone the repository
git clone https://github.com/your-org/laniakea.git
cd laniakea

# Setup server
cd server
mix deps.get
mix ecto.setup  # if using database

# Setup client
cd ../client
npm install

# Start both (in separate terminals)
cd server && mix phx.server
cd client && npm run dev

# Open http://localhost:5173 in multiple tabs
# Click "Increment" in both â€” watch values converge!
----

=== Demo: Collaborative Counter

1. Open the app in two browser tabs
2. Click "Increment" in Tab A â†’ both tabs show updated count
3. Disconnect Tab B from network (DevTools â†’ Offline)
4. Click "Increment" in Tab B â†’ local count increases
5. Reconnect Tab B â†’ watch CRDTs merge, counts converge

== Project Structure

[source]
----
laniakea/
â”œâ”€â”€ server/                      # Elixir/Phoenix
â”‚   â”œâ”€â”€ lib/laniakea/
â”‚   â”‚   â”œâ”€â”€ crdt/
â”‚   â”‚   â”‚   â”œâ”€â”€ g_counter.ex     # G-Counter implementation
â”‚   â”‚   â”‚   â”œâ”€â”€ pn_counter.ex    # PN-Counter implementation
â”‚   â”‚   â”‚   â””â”€â”€ registry.ex      # CRDT state registry
â”‚   â”‚   â”œâ”€â”€ command_bus.ex       # Typed command processing
â”‚   â”‚   â”œâ”€â”€ policy.ex            # Capability negotiation
â”‚   â”‚   â””â”€â”€ application.ex       # OTP supervision tree
â”‚   â”œâ”€â”€ lib/laniakea_web/
â”‚   â”‚   â”œâ”€â”€ channels/
â”‚   â”‚   â”‚   â”œâ”€â”€ crdt_channel.ex  # Phoenix Channel for sync
â”‚   â”‚   â”‚   â””â”€â”€ user_socket.ex
â”‚   â”‚   â””â”€â”€ endpoint.ex
â”‚   â””â”€â”€ config/
â”œâ”€â”€ client/                      # ReScript/Elm
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ crdt/
â”‚   â”‚   â”‚   â””â”€â”€ GCounter.res     # G-Counter mirror
â”‚   â”‚   â”œâ”€â”€ adapters/
â”‚   â”‚   â”‚   â”œâ”€â”€ Capabilities.res # Browser feature detection
â”‚   â”‚   â”‚   â””â”€â”€ Command.res      # Typed command envelopes
â”‚   â”‚   â”œâ”€â”€ transport/
â”‚   â”‚   â”‚   â””â”€â”€ Channel.res      # Phoenix channel bindings
â”‚   â”‚   â””â”€â”€ Main.res             # Application entry
â”‚   â””â”€â”€ index.html
â”œâ”€â”€ schemas/                     # Shared type definitions
â”‚   â”œâ”€â”€ commands.proto           # Protocol buffers
â”‚   â””â”€â”€ generators/              # Code generators
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ wiki/                    # Detailed documentation
â”‚   â”œâ”€â”€ whitepapers/             # Academic/industry papers
â”‚   â””â”€â”€ comparisons/             # Framework comparisons
â””â”€â”€ README.adoc                  # This file
----

== Documentation

=== Wiki

* link:docs/wiki/Home.md[Home] â€” Overview and navigation
* link:docs/wiki/Architecture.md[Architecture] â€” Detailed system design
* link:docs/wiki/CRDTs.md[CRDTs] â€” Conflict-free data types explained
* link:docs/wiki/Capability-Negotiation.md[Capability Negotiation] â€” Adaptive client profiles
* link:docs/wiki/Transport.md[Transport] â€” WebSocket/WebTransport/QUIC
* link:docs/wiki/FAQ.md[FAQ] â€” Frequently asked questions

=== Whitepapers

* link:docs/whitepapers/industry.md[Industry Whitepaper] â€” For practitioners
* link:docs/whitepapers/academic.md[Academic Paper] â€” For researchers
* link:docs/whitepapers/public.md[Public Overview] â€” For general audience

=== Comparisons

* link:docs/comparisons/elm-nextjs-react.md[Elm vs Next.js vs React] â€” Framework comparison
* link:docs/comparisons/liveview.md[vs LiveView] â€” Server-rendered comparison
* link:docs/comparisons/lumen.md[vs Lumen/Firefly] â€” Why we differ

== Contributing

We welcome contributions! See link:CONTRIBUTING.md[CONTRIBUTING.md] for guidelines.

=== Development

[source,bash]
----
# Run server tests
cd server && mix test

# Run client tests
cd client && npm test

# Type check
cd server && mix dialyzer
cd client && npm run typecheck
----

== Roadmap

_Updated: December 2025_

=== Phase 0 - Core Foundation (Completed)
* [x] G-Counter CRDT implementation (server + client)
* [x] PN-Counter CRDT implementation (server + client)
* [x] OR-Set CRDT implementation (server + client)
* [x] LWW-Register CRDT implementation (server + client)
* [x] Phoenix Channel transport
* [x] Capability negotiation protocol
* [x] ReScript client with isomorphic CRDTs
* [x] RSR compliance infrastructure
* [x] CI/CD with GitHub Actions + GitLab CI
* [x] Security hardening (SHA-pinned actions, SPDX headers)
* [x] Nix flake for reproducible builds

=== Phase 1 - Production Readiness (In Progress)
* [ ] Delta-based CRDT sync optimization
* [ ] Typed command/event envelopes with schema validation
* [ ] Schema generators (Protobuf/Cap'n Proto)
* [ ] Complete TS â†’ ReScript migration
* [ ] Comprehensive test coverage (>80%)
* [ ] Performance benchmarks
* [ ] Basic demo application with offline support

=== Phase 2 - Transport & Observability (Planned)
* [ ] WebTransport support
* [ ] Transport hedging (race WebSocket vs WebTransport)
* [ ] OpenTelemetry integration
* [ ] Backpressure monitoring
* [ ] Connection quality metrics
* [ ] QUIC experimentation

=== Phase 3 - Advanced CRDTs (Planned)
* [ ] RGA (Replicated Growable Array) for collaborative text
* [ ] CRDT garbage collection
* [ ] Causal stability optimization
* [ ] Large state sharding

=== Phase 4 - BEAM in Browser (Research)
* [ ] Evaluate Popcorn/AtomVM integration
* [ ] Zig/Wasm runtime bridge research
* [ ] Browser supervision trees
* [ ] Full distributed BEAM semantics
* [ ] OTP process support in browser

=== Continuous Improvements
* [ ] Add Containerfile for container builds
* [ ] Expand RSR compliance to Tier 1
* [ ] Documentation site with GitHub Pages
* [ ] Interactive playground/demo

== Prior Art & Inspiration

* https://github.com/lumen/lumen[Lumen/Firefly] â€” BEAM-to-Wasm compiler (archived)
* https://github.com/nicklockwood/Popcorn[Popcorn] â€” AtomVM in browser
* https://github.com/hologram-compiler/hologram[Hologram] â€” Elixir-to-JS transpiler
* https://github.com/lunatic-solutions/lunatic[Lunatic] â€” Erlang-inspired Wasm runtime
* https://automerge.org/[Automerge] â€” CRDT library
* https://github.com/yjs/yjs[Yjs] â€” CRDT framework
* https://www.phoenixframework.org/[Phoenix] â€” Elixir web framework
* https://rescript-lang.org/[ReScript] â€” Type-safe JS compiler

== License

Dual-licensed under MIT and Apache 2.0. See link:LICENSE[LICENSE] for details.

== Acknowledgments

This project builds on decades of distributed systems research, particularly:

* Marc Shapiro et al. â€” CRDT foundations
* Joe Armstrong â€” Erlang/OTP design
* Chris McCord â€” Phoenix framework
* The Elixir core team â€” Language and ecosystem

---

[quote, Carl Sagan]
____
The universe is a pretty big place. If it's just us, seems like an awful waste of space.
____

In the Laniakea architecture, your browser isn't alone â€” it's part of something bigger.
