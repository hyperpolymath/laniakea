// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "@rescript/runtime/lib/es6/Js_dict.js";
import * as GCounter from "./GCounter.mjs";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Belt_MapString from "@rescript/runtime/lib/es6/Belt_MapString.js";

function make() {
  return {
    positive: GCounter.make(),
    negative: GCounter.make(),
    version: 0
  };
}

function increment(counter, nodeId) {
  return {
    positive: GCounter.increment(counter.positive, nodeId),
    negative: counter.negative,
    version: counter.version + 1 | 0
  };
}

function incrementBy(counter, nodeId, amount) {
  return {
    positive: GCounter.incrementBy(counter.positive, nodeId, amount),
    negative: counter.negative,
    version: counter.version + 1 | 0
  };
}

function decrement(counter, nodeId) {
  return {
    positive: counter.positive,
    negative: GCounter.increment(counter.negative, nodeId),
    version: counter.version + 1 | 0
  };
}

function decrementBy(counter, nodeId, amount) {
  return {
    positive: counter.positive,
    negative: GCounter.incrementBy(counter.negative, nodeId, amount),
    version: counter.version + 1 | 0
  };
}

function value(counter) {
  return GCounter.value(counter.positive) - GCounter.value(counter.negative) | 0;
}

function positiveValue(counter) {
  return GCounter.value(counter.positive);
}

function negativeValue(counter) {
  return GCounter.value(counter.negative);
}

function merge(a, b) {
  return {
    positive: GCounter.merge(a.positive, b.positive),
    negative: GCounter.merge(a.negative, b.negative),
    version: Math.max(a.version, b.version) + 1 | 0
  };
}

function delta(older, newer) {
  return {
    positive: GCounter.delta(older.positive, newer.positive),
    negative: GCounter.delta(older.negative, newer.negative),
    version: newer.version
  };
}

function toWire(counter) {
  let posDict = {};
  let negDict = {};
  Belt_MapString.forEach(counter.positive.counts, (k, v) => {
    posDict[k] = v;
  });
  Belt_MapString.forEach(counter.negative.counts, (k, v) => {
    negDict[k] = v;
  });
  return {
    type: "pn_counter",
    positive: posDict,
    negative: negDict,
    version: counter.version,
    value: value(counter)
  };
}

function fromWire(wire) {
  let positive = Belt_MapString.fromArray(Belt_Array.map(Js_dict.entries(wire.positive), param => [
    param[0],
    param[1]
  ]));
  let negative = Belt_MapString.fromArray(Belt_Array.map(Js_dict.entries(wire.negative), param => [
    param[0],
    param[1]
  ]));
  return {
    positive: {
      counts: positive,
      version: 0
    },
    negative: {
      counts: negative,
      version: 0
    },
    version: wire.version
  };
}

export {
  make,
  increment,
  incrementBy,
  decrement,
  decrementBy,
  value,
  positiveValue,
  negativeValue,
  merge,
  delta,
  toWire,
  fromWire,
}
/* No side effect */
