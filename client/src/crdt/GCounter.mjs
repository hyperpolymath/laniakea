// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "@rescript/runtime/lib/es6/Js_dict.js";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";
import * as Belt_MapString from "@rescript/runtime/lib/es6/Belt_MapString.js";
import * as Belt_SetString from "@rescript/runtime/lib/es6/Belt_SetString.js";

function make() {
  return {
    counts: undefined,
    version: 0
  };
}

function fromMap(counts) {
  return {
    counts: counts,
    version: 0
  };
}

function increment(counter, nodeId) {
  let current = Belt_Option.getWithDefault(Belt_MapString.get(counter.counts, nodeId), 0);
  return {
    counts: Belt_MapString.set(counter.counts, nodeId, current + 1 | 0),
    version: counter.version + 1 | 0
  };
}

function incrementBy(counter, nodeId, amount) {
  let current = Belt_Option.getWithDefault(Belt_MapString.get(counter.counts, nodeId), 0);
  return {
    counts: Belt_MapString.set(counter.counts, nodeId, current + amount | 0),
    version: counter.version + 1 | 0
  };
}

function value(counter) {
  return Belt_Array.reduce(Belt_MapString.valuesToArray(counter.counts), 0, (a, b) => a + b | 0);
}

function nodeValue(counter, nodeId) {
  return Belt_Option.getWithDefault(Belt_MapString.get(counter.counts, nodeId), 0);
}

function merge(a, b) {
  let aKeys = Belt_SetString.fromArray(Belt_MapString.keysToArray(a.counts));
  let bKeys = Belt_SetString.fromArray(Belt_MapString.keysToArray(b.counts));
  let allNodes = Belt_SetString.union(aKeys, bKeys);
  let mergedCounts = Belt_SetString.reduce(allNodes, undefined, (acc, node) => {
    let countA = Belt_Option.getWithDefault(Belt_MapString.get(a.counts, node), 0);
    let countB = Belt_Option.getWithDefault(Belt_MapString.get(b.counts, node), 0);
    return Belt_MapString.set(acc, node, Math.max(countA, countB));
  });
  return {
    counts: mergedCounts,
    version: Math.max(a.version, b.version) + 1 | 0
  };
}

function delta(older, newer) {
  let deltaCounts = Belt_MapString.fromArray(Belt_Array.keep(Belt_MapString.toArray(newer.counts), param => {
    let oldCount = Belt_Option.getWithDefault(Belt_MapString.get(older.counts, param[0]), 0);
    return param[1] > oldCount;
  }));
  return {
    counts: deltaCounts,
    version: newer.version
  };
}

function equal(a, b) {
  return Belt_MapString.eq(a.counts, b.counts, (x, y) => x === y);
}

function lte(a, b) {
  let aKeys = Belt_SetString.fromArray(Belt_MapString.keysToArray(a.counts));
  let bKeys = Belt_SetString.fromArray(Belt_MapString.keysToArray(b.counts));
  let allNodes = Belt_SetString.union(aKeys, bKeys);
  return Belt_SetString.every(allNodes, node => {
    let countA = Belt_Option.getWithDefault(Belt_MapString.get(a.counts, node), 0);
    let countB = Belt_Option.getWithDefault(Belt_MapString.get(b.counts, node), 0);
    return countA <= countB;
  });
}

function toWire(counter) {
  let countsDict = {};
  Belt_MapString.forEach(counter.counts, (k, v) => {
    countsDict[k] = v;
  });
  return {
    type: "g_counter",
    counts: countsDict,
    version: counter.version,
    value: value(counter)
  };
}

function fromWire(wire) {
  let counts = Belt_MapString.fromArray(Belt_Array.map(Js_dict.entries(wire.counts), param => [
    param[0],
    param[1]
  ]));
  return {
    counts: counts,
    version: wire.version
  };
}

export {
  make,
  fromMap,
  increment,
  incrementBy,
  value,
  nodeValue,
  merge,
  delta,
  equal,
  lte,
  toWire,
  fromWire,
}
/* No side effect */
