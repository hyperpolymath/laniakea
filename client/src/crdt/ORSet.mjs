// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Id from "@rescript/runtime/lib/es6/Belt_Id.js";
import * as Belt_Set from "@rescript/runtime/lib/es6/Belt_Set.js";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";
import * as Primitive_int from "@rescript/runtime/lib/es6/Primitive_int.js";
import * as Belt_MapString from "@rescript/runtime/lib/es6/Belt_MapString.js";
import * as Belt_SetString from "@rescript/runtime/lib/es6/Belt_SetString.js";
import * as Primitive_option from "@rescript/runtime/lib/es6/Primitive_option.js";
import * as Primitive_string from "@rescript/runtime/lib/es6/Primitive_string.js";

function cmp(a, b) {
  let nodeCmp = Primitive_string.compare(a.node, b.node);
  if (nodeCmp !== 0) {
    return nodeCmp;
  } else {
    return Primitive_int.compare(a.ts, b.ts);
  }
}

let TagCmp = Belt_Id.MakeComparable({
  cmp: cmp
});

let emptyTagSet = Belt_Set.make(TagCmp);

function make() {
  return {
    elements: undefined,
    version: 0
  };
}

function generateTs() {
  return Date.now() | 0;
}

function add(set, element, nodeId) {
  let tag_ts = Date.now() | 0;
  let tag = {
    node: nodeId,
    ts: tag_ts
  };
  let existingTags = Belt_Option.getWithDefault(Belt_MapString.get(set.elements, element), emptyTagSet);
  let newTags = Belt_Set.add(existingTags, tag);
  return {
    elements: Belt_MapString.set(set.elements, element, newTags),
    version: set.version + 1 | 0
  };
}

function remove(set, element) {
  return {
    elements: Belt_MapString.remove(set.elements, element),
    version: set.version + 1 | 0
  };
}

function contains(set, element) {
  let tags = Belt_MapString.get(set.elements, element);
  if (tags !== undefined) {
    return Belt_Set.size(Primitive_option.valFromOption(tags)) > 0;
  } else {
    return false;
  }
}

function elements(set) {
  return Belt_Array.keep(Belt_MapString.keysToArray(set.elements), elem => contains(set, elem));
}

function size(set) {
  return elements(set).length;
}

function merge(a, b) {
  let aKeys = Belt_SetString.fromArray(Belt_MapString.keysToArray(a.elements));
  let bKeys = Belt_SetString.fromArray(Belt_MapString.keysToArray(b.elements));
  let allElements = Belt_SetString.union(aKeys, bKeys);
  let mergedElements = Belt_SetString.reduce(allElements, undefined, (acc, element) => {
    let tagsA = Belt_Option.getWithDefault(Belt_MapString.get(a.elements, element), emptyTagSet);
    let tagsB = Belt_Option.getWithDefault(Belt_MapString.get(b.elements, element), emptyTagSet);
    let mergedTags = Belt_Set.union(tagsA, tagsB);
    if (Belt_Set.size(mergedTags) > 0) {
      return Belt_MapString.set(acc, element, mergedTags);
    } else {
      return acc;
    }
  });
  return {
    elements: mergedElements,
    version: Math.max(a.version, b.version) + 1 | 0
  };
}

function toWire(set) {
  let elementsDict = {};
  Belt_MapString.forEach(set.elements, (element, tags) => {
    let tagsArray = Belt_Array.map(Belt_Set.toArray(tags), t => ({
      node: t.node,
      ts: t.ts
    }));
    elementsDict[element] = tagsArray;
  });
  return {
    type: "or_set",
    elements: elementsDict,
    version: set.version,
    value: elements(set)
  };
}

let value = elements;

export {
  TagCmp,
  emptyTagSet,
  make,
  generateTs,
  add,
  remove,
  contains,
  elements,
  value,
  size,
  merge,
  toWire,
}
/* TagCmp Not a pure module */
